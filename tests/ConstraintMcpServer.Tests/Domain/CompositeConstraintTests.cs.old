using System;
using System.Collections.Generic;
using System.Linq;
using FluentAssertions;
using NUnit.Framework;

namespace ConstraintMcpServer.Tests.Domain;

/// <summary>
/// Unit tests for CompositeConstraint domain model with composition logic.
/// Tests business rules for coordinating multiple atomic constraints in methodologies.
/// </summary>
[TestFixture]
public class CompositeConstraintTests
{
    [Test]
    public void Constructor_Should_RequireValidId()
    {
        // Arrange & Act & Assert
        Action createWithNullId = () => new CompositeConstraint(
            null!,
            "Composite Title",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new List<AtomicConstraint>(),
            new[] { "Composite reminder" });

        createWithNullId.Should().Throw<ArgumentNullException>()
            .WithParameterName("id");
    }

    [Test]
    public void Constructor_Should_RequireValidTitle()
    {
        // Arrange & Act & Assert
        Action createWithEmptyTitle = () => new CompositeConstraint(
            "composite.test",
            "",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new List<AtomicConstraint>(),
            new[] { "Composite reminder" });

        createWithEmptyTitle.Should().Throw<ValidationException>()
            .WithMessage("*title cannot be empty*");
    }

    [Test]
    public void Constructor_Should_RequireValidPriority()
    {
        // Arrange & Act & Assert
        Action createWithInvalidPriority = () => new CompositeConstraint(
            "composite.test",
            "Composite Title",
            1.5,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new List<AtomicConstraint>(),
            new[] { "Composite reminder" });

        createWithInvalidPriority.Should().Throw<ValidationException>()
            .WithMessage("*priority must be between 0.0 and 1.0*");
    }

    [Test]
    public void Constructor_Should_RequireAtLeastOneComponent()
    {
        // Arrange & Act & Assert
        Action createWithNoComponents = () => new CompositeConstraint(
            "composite.test",
            "Composite Title",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new List<AtomicConstraint>(),
            new[] { "Composite reminder" });

        createWithNoComponents.Should().Throw<ValidationException>()
            .WithMessage("*must have at least one component*");
    }

    [Test]
    public void Constructor_Should_ValidateSequentialCompositionOrder()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first", sequenceOrder: 1);
        var component2 = CreateAtomicConstraint("test.second", sequenceOrder: 1); // Duplicate order

        // Act & Assert
        Action createWithDuplicateOrder = () => new CompositeConstraint(
            "composite.sequential",
            "Sequential Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new[] { component1, component2 },
            new[] { "Sequential reminder" });

        createWithDuplicateOrder.Should().Throw<ValidationException>()
            .WithMessage("*sequential composition requires unique sequence orders*");
    }

    [Test]
    public void Constructor_Should_ValidateHierarchicalCompositionLevels()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.parent", hierarchyLevel: 1);
        var component2 = CreateAtomicConstraint("test.child", hierarchyLevel: -1); // Invalid level

        // Act & Assert
        Action createWithInvalidLevel = () => new CompositeConstraint(
            "composite.hierarchical",
            "Hierarchical Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Hierarchical,
            new[] { component1, component2 },
            new[] { "Hierarchical reminder" });

        createWithInvalidLevel.Should().Throw<ValidationException>()
            .WithMessage("*hierarchy levels must be non-negative*");
    }

    [Test]
    public void GetActiveComponents_Should_ReturnAllForParallelComposition()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first");
        var component2 = CreateAtomicConstraint("test.second");
        var component3 = CreateAtomicConstraint("test.third");

        var composite = new CompositeConstraint(
            "composite.parallel",
            "Parallel Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Parallel,
            new[] { component1, component2, component3 },
            new[] { "All components active simultaneously" });

        var context = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active
        };

        // Act
        var activeComponents = composite.GetActiveComponents(context);

        // Assert
        activeComponents.Should().HaveCount(3);
        activeComponents.Should().Contain(component1);
        activeComponents.Should().Contain(component2);
        activeComponents.Should().Contain(component3);
    }

    [Test]
    public void GetActiveComponents_Should_ReturnSequentiallyForSequentialComposition()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first", sequenceOrder: 1);
        var component2 = CreateAtomicConstraint("test.second", sequenceOrder: 2);
        var component3 = CreateAtomicConstraint("test.third", sequenceOrder: 3);

        var composite = new CompositeConstraint(
            "composite.sequential",
            "Sequential Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new[] { component1, component2, component3 },
            new[] { "Components activate in sequence" });

        var contextStep1 = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            SequenceStep = 1
        };

        var contextStep2 = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            SequenceStep = 2
        };

        // Act
        var activeAtStep1 = composite.GetActiveComponents(contextStep1);
        var activeAtStep2 = composite.GetActiveComponents(contextStep2);

        // Assert
        activeAtStep1.Should().HaveCount(1);
        activeAtStep1.Should().Contain(component1);

        activeAtStep2.Should().HaveCount(1);
        activeAtStep2.Should().Contain(component2);
    }

    [Test]
    public void GetActiveComponents_Should_ReturnHierarchicallyForHierarchicalComposition()
    {
        // Arrange
        var parentComponent = CreateAtomicConstraint("test.parent", hierarchyLevel: 1);
        var childComponent1 = CreateAtomicConstraint("test.child1", hierarchyLevel: 2);
        var childComponent2 = CreateAtomicConstraint("test.child2", hierarchyLevel: 2);

        var composite = new CompositeConstraint(
            "composite.hierarchical",
            "Hierarchical Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Hierarchical,
            new[] { parentComponent, childComponent1, childComponent2 },
            new[] { "Parent activates first, then children" });

        var contextLevel1 = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            HierarchyLevel = 1
        };

        var contextLevel2 = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            HierarchyLevel = 2
        };

        // Act
        var activeAtLevel1 = composite.GetActiveComponents(contextLevel1);
        var activeAtLevel2 = composite.GetActiveComponents(contextLevel2);

        // Assert
        activeAtLevel1.Should().HaveCount(1);
        activeAtLevel1.Should().Contain(parentComponent);

        activeAtLevel2.Should().HaveCount(2);
        activeAtLevel2.Should().Contain(childComponent1);
        activeAtLevel2.Should().Contain(childComponent2);
    }

    [Test]
    public void AdvanceComposition_Should_ProgressSequentialComposition()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first", sequenceOrder: 1);
        var component2 = CreateAtomicConstraint("test.second", sequenceOrder: 2);

        var composite = new CompositeConstraint(
            "composite.sequential",
            "Sequential Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new[] { component1, component2 },
            new[] { "Sequential composition" });

        var context = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            SequenceStep = 1
        };

        // Act
        var nextContext = composite.AdvanceComposition(context);

        // Assert
        nextContext.SequenceStep.Should().Be(2);
        nextContext.CurrentState.Should().Be(CompositionState.Active);
    }

    [Test]
    public void AdvanceComposition_Should_CompleteWhenSequenceFinished()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first", sequenceOrder: 1);
        var component2 = CreateAtomicConstraint("test.second", sequenceOrder: 2);

        var composite = new CompositeConstraint(
            "composite.sequential",
            "Sequential Test",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new[] { component1, component2 },
            new[] { "Sequential composition" });

        var context = new CompositionContext
        {
            TriggerContext = new TriggerContext(),
            CurrentState = CompositionState.Active,
            SequenceStep = 2
        };

        // Act
        var nextContext = composite.AdvanceComposition(context);

        // Assert
        nextContext.CurrentState.Should().Be(CompositionState.Completed);
    }

    [Test]
    public void MatchesTriggerContext_Should_DelegateTriggerMatching()
    {
        // Arrange
        var triggers = new TriggerConfiguration
        {
            Keywords = new[] { "outside-in", "atdd", "bdd" },
            ContextPatterns = new[] { "methodology", "full-stack" }
        };

        var component1 = CreateAtomicConstraint("test.atdd");
        var component2 = CreateAtomicConstraint("test.tdd");

        var composite = new CompositeConstraint(
            "methodology.outside-in",
            "Outside-In Development",
            0.95,
            triggers,
            CompositionType.Sequential,
            new[] { component1, component2 },
            new[] { "Outside-In methodology" });

        var matchingContext = new TriggerContext
        {
            Keywords = new[] { "implementing outside-in development with atdd" },
            ContextType = "methodology"
        };

        var nonMatchingContext = new TriggerContext
        {
            Keywords = new[] { "frontend styling components" },
            ContextType = "ui-development"
        };

        // Act
        var matchesGoodContext = composite.MatchesTriggerContext(matchingContext);
        var matchesBadContext = composite.MatchesTriggerContext(nonMatchingContext);

        // Assert
        matchesGoodContext.Should().BeTrue();
        matchesBadContext.Should().BeFalse();
    }

    [Test]
    public void ToString_Should_IncludeCompositionInformation()
    {
        // Arrange
        var component1 = CreateAtomicConstraint("test.first");
        var component2 = CreateAtomicConstraint("test.second");

        var composite = new CompositeConstraint(
            "composite.test",
            "Test Composite",
            0.9,
            new TriggerConfiguration(),
            CompositionType.Sequential,
            new[] { component1, component2 },
            new[] { "Composite reminder" });

        // Act
        var result = composite.ToString();

        // Assert
        result.Should().Contain("composite.test");
        result.Should().Contain("Priority: 0.9");
        result.Should().Contain("Composite");
        result.Should().Contain("Sequential");
        result.Should().Contain("2 components");
    }

    // Helper method to create atomic constraints for testing
    private AtomicConstraint CreateAtomicConstraint(
        string id,
        int? sequenceOrder = null,
        int? hierarchyLevel = null)
    {
        var triggers = new TriggerConfiguration();
        
        // This will need to be updated when AtomicConstraint is implemented
        // For now, this represents the expected interface
        return new AtomicConstraint(
            id,
            $"Title for {id}",
            0.8,
            triggers,
            new[] { $"Reminder for {id}" })
        {
            SequenceOrder = sequenceOrder,
            HierarchyLevel = hierarchyLevel
        };
    }
}