using System;
using System.Collections.Generic;
using System.Linq;
using FluentAssertions;
using NUnit.Framework;

namespace ConstraintMcpServer.Tests.Domain;

/// <summary>
/// Unit tests for AtomicConstraint domain model with trigger-based activation.
/// Tests business rules and domain logic for individual constraint building blocks.
/// </summary>
[TestFixture]
public class AtomicConstraintTests
{
    [Test]
    public void Constructor_Should_RequireValidId()
    {
        // Arrange & Act & Assert
        Action createWithNullId = () => new AtomicConstraint(
            null!,
            "Test Title", 
            0.8,
            new TriggerConfiguration(),
            new[] { "Test reminder" });

        createWithNullId.Should().Throw<ArgumentNullException>()
            .WithParameterName("id");
    }

    [Test]
    public void Constructor_Should_RequireValidTitle()
    {
        // Arrange & Act & Assert
        Action createWithNullTitle = () => new AtomicConstraint(
            "test.constraint",
            null!,
            0.8,
            new TriggerConfiguration(),
            new[] { "Test reminder" });

        createWithNullTitle.Should().Throw<ArgumentNullException>()
            .WithParameterName("title");

        Action createWithEmptyTitle = () => new AtomicConstraint(
            "test.constraint",
            "",
            0.8,
            new TriggerConfiguration(), 
            new[] { "Test reminder" });

        createWithEmptyTitle.Should().Throw<ValidationException>()
            .WithMessage("*title cannot be empty*");
    }

    [Test]
    public void Constructor_Should_RequireValidPriority()
    {
        // Arrange & Act & Assert
        Action createWithNegativePriority = () => new AtomicConstraint(
            "test.constraint",
            "Test Title",
            -0.1,
            new TriggerConfiguration(),
            new[] { "Test reminder" });

        createWithNegativePriority.Should().Throw<ValidationException>()
            .WithMessage("*priority must be between 0.0 and 1.0*");

        Action createWithTooHighPriority = () => new AtomicConstraint(
            "test.constraint", 
            "Test Title",
            1.1,
            new TriggerConfiguration(),
            new[] { "Test reminder" });

        createWithTooHighPriority.Should().Throw<ValidationException>()
            .WithMessage("*priority must be between 0.0 and 1.0*");
    }

    [Test]
    public void Constructor_Should_RequireValidTriggerConfiguration()
    {
        // Arrange & Act & Assert
        Action createWithNullTriggers = () => new AtomicConstraint(
            "test.constraint",
            "Test Title",
            0.8,
            null!,
            new[] { "Test reminder" });

        createWithNullTriggers.Should().Throw<ArgumentNullException>()
            .WithParameterName("triggers");
    }

    [Test]
    public void Constructor_Should_RequireAtLeastOneReminder()
    {
        // Arrange & Act & Assert
        Action createWithNoReminders = () => new AtomicConstraint(
            "test.constraint",
            "Test Title", 
            0.8,
            new TriggerConfiguration(),
            new string[0]);

        createWithNoReminders.Should().Throw<ValidationException>()
            .WithMessage("*must have at least one reminder*");

        Action createWithNullReminders = () => new AtomicConstraint(
            "test.constraint",
            "Test Title",
            0.8,
            new TriggerConfiguration(),
            null!);

        createWithNullReminders.Should().Throw<ArgumentNullException>()
            .WithParameterName("reminders");
    }

    [Test]
    public void Constructor_Should_RejectEmptyOrWhitespaceReminders()
    {
        // Arrange & Act & Assert
        Action createWithEmptyReminder = () => new AtomicConstraint(
            "test.constraint",
            "Test Title",
            0.8,
            new TriggerConfiguration(),
            new[] { "Valid reminder", "", "Another valid" });

        createWithEmptyReminder.Should().Throw<ValidationException>()
            .WithMessage("*reminders must be non-empty*");

        Action createWithWhitespaceReminder = () => new AtomicConstraint(
            "test.constraint", 
            "Test Title",
            0.8,
            new TriggerConfiguration(),
            new[] { "Valid reminder", "   ", "Another valid" });

        createWithWhitespaceReminder.Should().Throw<ValidationException>()
            .WithMessage("*reminders must be non-empty*");
    }

    [Test]
    public void MatchesTriggerContext_Should_ReturnTrueForMatchingKeywords()
    {
        // Arrange
        var triggers = new TriggerConfiguration
        {
            Keywords = new[] { "test", "unit test", "tdd" },
            FilePatterns = new[] { "*Test.cs" },
            ContextPatterns = new[] { "testing" }
        };

        var constraint = new AtomicConstraint(
            "test.constraint",
            "Test First",
            0.8,
            triggers,
            new[] { "Write tests first" });

        var context = new TriggerContext
        {
            Keywords = new[] { "writing unit test for service" },
            FilePath = "UserServiceTest.cs",
            ContextType = "testing"
        };

        // Act
        bool matches = constraint.MatchesTriggerContext(context);

        // Assert
        matches.Should().BeTrue();
    }

    [Test]
    public void MatchesTriggerContext_Should_ReturnFalseForAntiPatterns()
    {
        // Arrange
        var triggers = new TriggerConfiguration
        {
            Keywords = new[] { "test", "tdd" },
            FilePatterns = new[] { "*Test.cs" },
            ContextPatterns = new[] { "testing" },
            AntiPatterns = new[] { "hotfix", "emergency" }
        };

        var constraint = new AtomicConstraint(
            "test.constraint",
            "Test First", 
            0.8,
            triggers,
            new[] { "Write tests first" });

        var context = new TriggerContext
        {
            Keywords = new[] { "hotfix unit test issue" },
            FilePath = "UserServiceTest.cs", 
            ContextType = "testing"
        };

        // Act
        bool matches = constraint.MatchesTriggerContext(context);

        // Assert  
        matches.Should().BeFalse();
    }

    [Test]
    public void CalculateRelevanceScore_Should_ReturnHighScoreForExactMatch()
    {
        // Arrange
        var triggers = new TriggerConfiguration
        {
            Keywords = new[] { "single responsibility", "class design" },
            FilePatterns = new[] { "*.cs" },
            ContextPatterns = new[] { "refactoring", "architecture" }
        };

        var constraint = new AtomicConstraint(
            "arch.single-responsibility",
            "Single Responsibility Principle",
            0.9,
            triggers,
            new[] { "Each class should have one reason to change" });

        var context = new TriggerContext
        {
            Keywords = new[] { "refactoring class with single responsibility principle" },
            FilePath = "UserService.cs",
            ContextType = "refactoring"
        };

        // Act
        double score = constraint.CalculateRelevanceScore(context);

        // Assert
        score.Should().BeGreaterThan(0.8);
    }

    [Test]
    public void CalculateRelevanceScore_Should_ReturnLowScoreForPoorMatch()
    {
        // Arrange  
        var triggers = new TriggerConfiguration
        {
            Keywords = new[] { "database", "repository" },
            FilePatterns = new[] { "*Repository.cs" },
            ContextPatterns = new[] { "data-access" }
        };

        var constraint = new AtomicConstraint(
            "data.repository-pattern",
            "Repository Pattern",
            0.7,
            triggers,
            new[] { "Use repository pattern for data access" });

        var context = new TriggerContext
        {
            Keywords = new[] { "frontend component styling" },
            FilePath = "Button.tsx",
            ContextType = "ui-development"
        };

        // Act
        double score = constraint.CalculateRelevanceScore(context);

        // Assert
        score.Should().BeLessThan(0.3);
    }

    [Test]
    public void ToString_Should_ReturnReadableRepresentation()
    {
        // Arrange
        var constraint = new AtomicConstraint(
            "test.write-first",
            "Write Tests First", 
            0.85,
            new TriggerConfiguration(),
            new[] { "Always write failing test first" });

        // Act
        string result = constraint.ToString();

        // Assert
        result.Should().Contain("test.write-first");
        result.Should().Contain("Priority: 0.85");
        result.Should().Contain("Atomic");
    }

    [Test]
    public void Equals_Should_CompareByIdOnly()
    {
        // Arrange
        var constraint1 = new AtomicConstraint(
            "same.id",
            "Title 1",
            0.8,
            new TriggerConfiguration(), 
            new[] { "Reminder 1" });

        var constraint2 = new AtomicConstraint(
            "same.id",
            "Title 2", 
            0.9,
            new TriggerConfiguration(),
            new[] { "Reminder 2" });

        var constraint3 = new AtomicConstraint(
            "different.id",
            "Title 1",
            0.8,
            new TriggerConfiguration(),
            new[] { "Reminder 1" });

        // Act & Assert
        constraint1.Should().Be(constraint2);
        constraint1.Should().NotBe(constraint3);
        constraint1.GetHashCode().Should().Be(constraint2.GetHashCode());
    }
}